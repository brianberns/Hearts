namespace Hearts.Model

open System

open MathNet.Numerics.LinearAlgebra

open PlayingCards
open Hearts

module Strategy =

    /// Creates a one-hot strategy vector.
    let createOneHot idx n =
        DenseVector.init n (fun i ->
            if i = idx then 1.0f else 0.0f)

    /// Computes strategy from the given per-action regrets.
    /// A strategy is normalized so that its elements sum
    /// to 1.0 (to represent action probabilities).
    let private matchRegrets regrets =

            // find highest-value action
        let idx = Vector.maxIndex regrets

            // scale if possible, or choose highest-value action
        if regrets[idx] > 0.0f then
            let clamped = Vector.map (max 0.0f) regrets   // clamp negative regrets
            clamped / Vector.sum clamped
        else
            DenseVector.init regrets.Count (fun i ->
                if i = idx then 1.0f
                else 0.0f)

    /// Converts a wide vector (indexed by entire deck) to
    /// a narrow vector (indexed by legal actions).
    let private toNarrow (legalActions : _[]) (wide : Vector<_>) =
        assert(wide.Count = Card.numCards)
        legalActions
            |> Seq.map (
                Card.toIndex >> Vector.get wide)
            |> DenseVector.ofSeq

    /// Converts a narrow vector (indexed by legal actions) to
    /// a wide vector (indexed by entire deck).
    let toWide (legalActions : _[]) (narrow : Vector<float32>) =
        assert(narrow.Count = legalActions.Length)
        Seq.zip legalActions narrow
            |> Encoding.encodeCardValues
            |> DenseVector.ofArray

    /// Computes strategies for the given info sets using the
    /// given advantage model.
    let getFromAdvantage model infoSets =

        if Array.length infoSets > 0 then

                // run model on GPU
            use advantages =
                AdvantageModel.getAdvantages infoSets model
            assert(advantages.shape[0] = infoSets.Length)

                // access data on CPU
            let nCols = int advantages.shape[1]
            assert(nCols = Model.outputSize)
            let data =
                use advantages =   // avoid memory leak (https://github.com/dotnet/TorchSharp/issues/1517)
                    advantages.``to``(
                        TorchSharp.torch.CPU, disposeAfter=true)
                use accessor = advantages.data<float32>()
                accessor.ToArray()
            [|
                for iRow, infoSet in Seq.indexed infoSets do
                    let iStart = iRow * nCols
                    data[iStart .. iStart + nCols - 1]
                        |> DenseVector.ofSeq
                        |> toNarrow infoSet.LegalActions
                        |> matchRegrets
            |]

        else Array.empty

    /// Computes strategy for the given info set using the
    /// given advantage model.
    let private getStrategy model infoSet =
        getFromAdvantage model [|infoSet|]
            |> Array.exactlyOne

    /// Creates a deterministic Hearts player using the given
    /// model.
    let createPlayerDeterministic model =

        let act infoSet =
            getStrategy model infoSet
                |> Vector.maxIndex
                |> Array.get infoSet.LegalActions

        { Act = act }

    /// Creates a non-deterministic Hearts player using the
    /// given model.
    let createPlayerNondeterministic model =

        let rng = Random()

        let act infoSet =
            getStrategy model infoSet
                |> Vector.sample rng
                |> Array.get infoSet.LegalActions

        { Act = act }
